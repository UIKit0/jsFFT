<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>FFT Demo in Javascript</title>
	
	<style>
		body  { font-family:Verdana, Geneva, sans-serif; font-size:10pt; color:#828282; }
	</style>

	<script src="./Chart.js"></script>
	<script src="./jsFFT.js"></script>
	<script src="./chartUtils.js"></script>
	<!-- jquery just used for the tabs -->
<!--<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">-->
	<script src="http://code.jquery.com/jquery-1.10.2.js"></script>
	<script src="http://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
	<script src="./dat.gui.min.js"></script>

	<script>
	  $(function() {
	    $("#tabs").tabs();
	  });
	  </script>
</head>
<body>

	<h3>FFT Demo in Javascript</h3>
	<p>This page was motivated for a quick test page for some FFT code, specifically using the
		half real transform. I'm using the <a href="http://www.chartjs.org/">Chart.js</a>
		 library to display the data.</p>
	<p>The charts below illustrate various ways to apply a dft/fft. (Click headings to
		view text and graphs.)</p>

	<!-- package demo in selectable div sections -->
	<div id="tabs">
	  <ul>
	    <li><a href="#t1">Real Valued Signal to Complex</a></li>
	    <li><a href="#t2">Complex Forward FFT and Magnitude</a></li>
	    <li><a href="#t3">Full Length Inverse Transform</a></li>
	    <li><a href="#t4">Packing a Real Signal to Half Complex</a></li>
	    <li><a href="#t5">Half Length FFT of Packed Real Signal</a></li>
	    <li><a href="#t6">Half Length Inverse Transform</a></li>
	  </ul>
	  <div id="t1">
		<p><b>Real Valued Signal to Complex</b></p>
	    <p>For a real valued signal, we must pad it into a complex signal
		and zero out the imaginary term. In the charts below, you can see this step of creating a
		new series of complex values. Real in blue, imaginary in red.</p>
		<div id="t1c"></div>
	  </div>
	  <div id="t2">
		<p><b>Complex Forward FFT and Magnitude</b></p>
	    <p>The following shows the complex forward transform and magnitude of the complex 
		signal.</p>
		<div id="t2c"></div>
	  </div>
	  <div id="t3">
		<p><b>Full Length Inverse Transform</b></p>
	    <p>The transform of the complex signal can be inverse transformed back to the
		original signal by applying the FFT in the reverse direction and rescaling. The
		axes change slightly due to math errors since floating point math has only a
		finite accuracy.</p>
		<div id="t3c"></div>
	  </div>
	  <div id="t4">
		<p><b>Packing a Real Signal to Half Complex</b></p>
	    <p>As a significant efficiency improvement, a signal that consists of only real 
		values can be chopped in half and even n placed in the real part, and
		odd n placed in the complex part of a half length complex transform.</p>
		<div id="t4c"></div>
	  </div>
	  <div id="t5">
		<p><b>Half Length FFT of Packed Real Signal</b></p>
	    <p></p>
		<div id="t5c"></div>
	  </div>
	  <div id="t6">
		<p><b>Half Length Inverse Transform</b></p>
	    <p></p>
		<div id="t6c"></div>
	  </div>
	</div>


	<script>

	var FFTLEN = 128;
	var CHARTLEN = FFTLEN<<1;

	// function to use for real signal
	var f1 = 3*FFTLEN/19;
	var f2 = 7*FFTLEN/19;
	var f3 = 12*FFTLEN/19;
	sinfunc = function(i,fftlen) {
		return Math.sin(f1*i*2*Math.PI/FFTLEN)
 		+Math.sin(Math.PI/2+f2*i*2*Math.PI/FFTLEN)
 		+Math.sin(Math.PI/4+f3*i*2*Math.PI/FFTLEN);
	}
	impulsefunc = function(i,fftlen) {
		if(i==Math.round(fftlen/3))
			return 1;
		return 0;
	}
	shelffunc = function(i,fftlen) {
		if(i<fftlen/3) {
			return 1;
		};
		return 0;
	}

	// Add controls
	var gui = new dat.GUI();
	var resetfft = gui.add(window, 'FFTLEN', {8:8,16:16,32:32,64:64,128:128,256:256});

	resetfft.onFinishChange( function(value) {
		// redraw fft with new parameters
		alert("values changed: " + FFTLEN);
	})

	// ==================== t1: Real Signal to Complex ====================
	
	// populate N real signal and chart it
	var realdata = populateFullReal(FFTLEN,impulsefunc);
	output("t1c","Real-valued signal (" + FFTLEN + " points)");
	chartBuffer("t1c",realdata,[{start:0,count:FFTLEN,stride:1,color:"rgba(151,187,205,0.8)"},]);
	
	// populate N real signal into complex signal and chart it
	var cplxdata = makeComplex(realdata,FFTLEN);
	output("t1c","Complex-valued signal (" + FFTLEN + " complex points)");
	chartBuffer("t1c",cplxdata,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						  {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.5)"},]);

	// ==================== t2: Complex FFT ====================

	// plot the complex valued signal
	output("t2c","Complex-valued signal (" + FFTLEN + " complex points)");
	chartBuffer("t2c",cplxdata,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						  {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.5)"},]);

	// forward transform the complex signal
	var fftdata = jsFFT(cplxdata,FFTLEN,1);
	output("t2c",""+FFTLEN+"-point Complex FFT");
	chartBuffer("t2c",fftdata,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						 {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.5)"},]);

	// calculate magnitude
	var magdata = jsMagnitude(fftdata,FFTLEN);
	output("t2c","Magnitude");
	chartBuffer("t2c",magdata,[{start:0,count:FFTLEN/2,stride:1,color:"rgba(151,187,205,0.8)"},]);

	// ==================== t3: Complex Inverse Transform ====================

	// plot the complex valued signal
	output("t3c","Complex-valued signal (" + FFTLEN + " complex points)");
	chartBuffer("t3c",cplxdata,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						  {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.5)"},]);

	// plot the transform from complex
	output("t3c",""+FFTLEN+"-point Complex FFT");
	chartBuffer("t3c",fftdata,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						 {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.5)"},]);

	// reverse transform to recover original signal
	var iftdata = jsFFT(fftdata,FFTLEN,-1);
	output("t3c","Inverse transform to recover original signal");
	chartBuffer("t3c",iftdata,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						 {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.5)"},]);

	// ==================== t4: Half Length Packed Real ====================

	// plot original real valued signal
	output("t4c","Real-valued signal (" + FFTLEN + " points)");
	chartBuffer("t4c",realdata,[{start:0,count:FFTLEN,stride:1,color:"rgba(151,187,205,0.8)"},]);
	
	// create a N/2 complex array from N point real signal
	var halfcplxdata = packRealToHalfComplex(realdata,FFTLEN);
	output("t4c","Half length N/2 packed-real complex signal");
	chartBuffer("t4c",halfcplxdata,[{start:0,count:FFTLEN/2,stride:2,color:"rgba(151,187,205,0.8)"},
						      {start:1,count:FFTLEN/2,stride:2,color:"rgba(235,151,151,0.8)"},]);

	// ==================== t5: Half Complex Transform ====================

	// plot original real valued signal
	output("t5c","Real-valued signal (" + FFTLEN + " points)");
	chartBuffer("t5c",realdata,[{start:0,count:FFTLEN,stride:1,color:"rgba(151,187,205,0.8)"},]);
	
	// plot half length complex signal
	output("t5c","Half length N/2 packed-real complex signal");
	chartBuffer("t5c",halfcplxdata,[{start:0,count:FFTLEN/2,stride:2,color:"rgba(151,187,205,0.8)"},
						      {start:1,count:FFTLEN/2,stride:2,color:"rgba(235,151,151,0.8)"},]);

	// Apply a half length complex FFT to packed real signal
	var halfcplxfft = jsRealFFT(halfcplxdata,FFTLEN,1);
	output("t5c","N/2 complex FFT of packed real signal");
	chartBuffer("t5c",halfcplxfft,[{start:0,count:FFTLEN/2,stride:2,color:"rgba(151,187,205,0.8)"},
								{start:1,count:FFTLEN/2,stride:2,color:"rgba(235,151,151,0.8)"},]);

	// Unpack half-length transform to hermitian
	var cplxfft = unpackHalfComplexFFT(halfcplxfft,FFTLEN);		// pass full length
	output("t5c","Unpacked half length transform (equivalent to result from full transform)");
	chartBuffer("t5c",cplxfft,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						 	  {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.8)"},]);

	// Apply regular inverse transform (verify we can recover original signal)
	var invunpackedfft = jsFFT(cplxfft,FFTLEN,-1);
	output("t5c","Apply full inverse transform to verify we can recover original signal");
	chartBuffer("t5c",invunpackedfft,[{start:0,count:FFTLEN,stride:2,color:"rgba(151,187,205,0.8)"},
						 {start:1,count:FFTLEN,stride:2,color:"rgba(235,151,151,0.8)"},]);


	// ==================== t6: Half Length Inverse Transform ====================

	// create a N/2 complex array from N point real signal
	var halfcplxdata = packRealToHalfComplex(realdata,FFTLEN);
	output("t6c","Half length N/2 packed-real complex signal");
	chartBuffer("t6c",halfcplxdata,[{start:0,count:FFTLEN/2,stride:2,color:"rgba(151,187,205,0.8)"},
						      {start:1,count:FFTLEN/2,stride:2,color:"rgba(235,151,151,0.8)"},]);

	// Half length complex transform
	output("t6c","Half length transform");
	chartBuffer("t6c",halfcplxfft,[{start:0,count:FFTLEN/2,stride:2,color:"rgba(151,187,205,0.8)"},
							 {start:1,count:FFTLEN/2,stride:2,color:"rgba(235,151,151,0.8)"},]);

	// inverse FFT on packed half complex
	var invhalfcplxfft = jsRealFFT(halfcplxfft,FFTLEN,-1);
	output("t6c","Inverse FFT on packed transform");
	chartBuffer("t6c",invhalfcplxfft,[{start:0,count:FFTLEN/2,stride:2,color:"rgba(151,187,205,0.8)"},
						             {start:1,count:FFTLEN/2,stride:2,color:"rgba(235,151,151,0.8)"},]);
	//

	</script>
</body>
</html>